<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Body Tracking</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000; /* Black background for the page */
        }
        /* Make the container fill the entire screen, fixed in the background */
        .stack-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        /* Make video and canvas fill the container, covering the area without distortion */
        .stack-container > * {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #webcam {
            display: none;
        }
        /* UI Overlay container */
        .ui-overlay {
            position: fixed;
            inset: 0; /* top, right, bottom, left = 0 */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            pointer-events: none; /* Allows clicks to 'go through' the container */
        }
        /* Re-enable pointer events for elements inside the overlay */
        .ui-overlay > * {
            pointer-events: auto;
        }
        /* Container to push buttons to the bottom */
        .controls-container {
            margin-top: auto;
            text-align: center;
        }
    </style>
</head>
<body class="bg-black text-white">

    <!-- Container for the video feed and canvas, now in the background -->
    <div id="liveView" class="stack-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- UI Elements that overlay the video feed -->
    <div class="ui-overlay">

        <div class="controls-container">
            <div class="flex items-center justify-center gap-4">
                 <button id="webcamButton" class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold py-3 px-8 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                    Enable Webcam
                </button>
                <button id="toggleBgButton" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-8 rounded-full shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out" style="display: none;">
                    Show Webcam
                </button>
            </div>
             <div id="loading" class="text-gray-400 mt-4" style="display: none;">
                <svg class="animate-spin h-5 w-5 mr-3 inline-block" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Loading AI Model...
            </div>
        </div>
    </div>

    <!-- MediaPipe Vision Tasks -->
    <script type="module">
        import {
            PoseLandmarker,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // Get DOM elements
        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const webcamButton = document.getElementById("webcamButton");
        const loadingElement = document.getElementById("loading");
        const liveView = document.getElementById("liveView");
        const toggleBgButton = document.getElementById("toggleBgButton");

        let poseLandmarker = undefined;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        let drawingUtils;
        let lastVideoTime = -1;
        let smoothedLandmarks; // Variable to store the smoothed landmark data
        let isWebcamBackground = false; // State for background toggle

        // --- 1. INITIALIZE THE MODEL ---
        const createPoseLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    // Use a lighter model for better performance on the web
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numPoses: 1 // Track a single person for this demo
            });
            drawingUtils = new DrawingUtils(canvasCtx);
            // Hide loading and enable the button once the model is ready
            loadingElement.style.display = 'none';
            webcamButton.disabled = false;
            console.log("PoseLandmarker model loaded.");
        };

        // Show loading and start creating the model
        webcamButton.disabled = true;
        loadingElement.style.display = 'block';
        createPoseLandmarker();

        // --- 2. ENABLE WEBCAM AND START PREDICTIONS ---
        const enableCam = (event) => {
            if (!poseLandmarker) {
                console.log("Wait! poseLandmarker not loaded yet.");
                return;
            }

            if (webcamRunning) {
                webcamRunning = false;
                webcamButton.innerText = "Enable Webcam";
                video.pause();
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                smoothedLandmarks = undefined; // Reset smoothing on disable
                toggleBgButton.style.display = 'none'; // Hide the toggle button
                video.style.display = 'none'; // Hide video element
                isWebcamBackground = false; // Reset background state
            } else {
                webcamRunning = true;
                webcamButton.innerText = "Disable Webcam";
                toggleBgButton.style.display = 'inline-block'; // Show the toggle button
                toggleBgButton.innerText = 'Show Webcam'; // Reset button text

                // Activate the webcam stream
                navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                    video.srcObject = stream;
                    // When the video data is loaded, set canvas dimensions and start the loop
                    video.addEventListener("loadeddata", startPredictionLoop);
                }).catch((err) => {
                    console.error("Error accessing webcam: ", err);
                    webcamRunning = false;
                    webcamButton.innerText = "Enable Webcam";
                });
            }
        };

        webcamButton.addEventListener("click", enableCam);

        toggleBgButton.addEventListener("click", () => {
            isWebcamBackground = !isWebcamBackground;
            if (isWebcamBackground) {
                video.style.display = 'block';
                toggleBgButton.innerText = 'Hide Webcam';
            } else {
                video.style.display = 'none';
                toggleBgButton.innerText = 'Show Webcam';
            }
        });

        // --- 3. PREDICTION LOOP ---
        const startPredictionLoop = () => {
            // Set canvas size to match video feed ONCE
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;
            // Start the continuous prediction loop
            predictWebcam();
        }

        const predictWebcam = async () => {
            // No longer need to set canvas size here, preventing the flicker.

            // Smoothing factor - lower value means more smoothing but more latency
            const smoothingFactor = 0.25;

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
                    canvasCtx.save();
                    
                    // Clear canvas. If webcam is visible, this makes it transparent.
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    
                    // If webcam background is off, draw a black background.
                    if (!isWebcamBackground) {
                        canvasCtx.fillStyle = "black";
                        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                    }

                    // --- Smoothing Logic ---
                    if (result.landmarks && result.landmarks.length > 0) {
                        const newLandmarks = result.landmarks[0];

                        if (!smoothedLandmarks) {
                            // If it's the first detection, initialize with a deep copy of the landmarks
                            smoothedLandmarks = JSON.parse(JSON.stringify(newLandmarks));
                        } else {
                            // Apply Exponential Moving Average to each landmark
                            for (let i = 0; i < newLandmarks.length; i++) {
                                smoothedLandmarks[i].x = smoothingFactor * newLandmarks[i].x + (1 - smoothingFactor) * smoothedLandmarks[i].x;
                                smoothedLandmarks[i].y = smoothingFactor * newLandmarks[i].y + (1 - smoothingFactor) * smoothedLandmarks[i].y;
                                smoothedLandmarks[i].z = smoothingFactor * newLandmarks[i].z + (1 - smoothingFactor) * smoothedLandmarks[i].z;
                                // We can just take the latest visibility value
                                smoothedLandmarks[i].visibility = newLandmarks[i].visibility;
                            }
                        }

                        // Draw the SMOOTHED landmarks and connections
                        drawingUtils.drawLandmarks(smoothedLandmarks, {
                            radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1),
                            color: '#FFFFFF' // white dots
                        });
                        drawingUtils.drawConnectors(smoothedLandmarks, PoseLandmarker.POSE_CONNECTIONS, {
                            color: (data) => {
                                // Gradient color for connections
                                const t = (data.from.z + data.to.z) / 2 + 0.5;
                                const r = Math.floor(255 * (1 - t) + 171 * t); // from FF to AB (pink to purple)
                                const g = Math.floor(0 * (1 - t) + 71 * t);
                                const b = Math.floor(255 * (1 - t) + 188 * t);
                                return `rgb(${r},${g},${b})`;
                            },
                             lineWidth: 3
                        });
                    }
                    canvasCtx.restore();
                });
            }

            // Call this function again to keep predicting when the browser is ready
            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        };
    </script>
</body>
</html>








