<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Body Tracking</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000; /* Black background for the page */
        }
        /* Make the container fill the entire screen, fixed in the background */
        .stack-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            perspective: 1000px; /* Add perspective for 3D transforms */
        }
        /* Make video and canvas fill the container, covering the area without distortion */
        .stack-container > * {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #output_canvas {
            transform-origin: 0 0; /* Set transform origin for predictable transformations */
            border: 2px solid red; /* Add a red border to show the canvas limits */
        }
        #webcam {
            display: none;
        }
        /* UI Overlay container */
        .ui-overlay {
            position: fixed;
            inset: 0; /* top, right, bottom, left = 0 */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            pointer-events: none; /* Allows clicks to 'go through' the container */
        }
        /* Re-enable pointer events for elements inside the overlay */
        .ui-overlay > * {
            pointer-events: auto;
        }
        /* Container to push buttons to the bottom */
        .controls-container {
            margin-top: auto;
            text-align: center;
        }
        /* Styles for the perspective controls */
        #perspective-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 0.5rem;
            border-radius: 0.5rem;
            display: none; /* Hidden by default */
            font-size: 0.75rem;
            width: 200px;
        }
        #perspective-controls h4 {
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        #perspective-controls label {
            display: block;
            margin-bottom: 0.1rem;
        }
        #perspective-controls input[type="range"] {
            width: 100%;
            margin-bottom: 0.25rem;
        }
        #toggleUiButton {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            z-index: 20;
            display: none; /* Hidden by default */
            pointer-events: auto;
        }
    </style>
</head>
<body class="bg-black text-white">

    <!-- Container for the video feed and canvas, now in the background -->
    <div id="liveView" class="stack-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- UI Elements that overlay the video feed -->
    <div class="ui-overlay">

        <div id="perspective-controls">
            <h4 class="font-bold mb-2">Perspective Controls</h4>
            <div>
                <label for="tlx">Top Left X</label>
                <input type="range" id="tlx" min="0" max="100" value="0">
                <label for="tly">Top Left Y</label>
                <input type="range" id="tly" min="0" max="100" value="0">
            </div>
            <div class="mt-2">
                <label for="trx">Top Right X</label>
                <input type="range" id="trx" min="0" max="100" value="100">
                <label for="try">Top Right Y</label>
                <input type="range" id="try" min="0" max="100" value="0">
            </div>
             <div class="mt-2">
                <label for="brx">Bottom Right X</label>
                <input type="range" id="brx" min="0" max="100" value="100">
                <label for="bry">Bottom Right Y</label>
                <input type="range" id="bry" min="0" max="100" value="100">
            </div>
             <div class="mt-2">
                <label for="blx">Bottom Left X</label>
                <input type="range" id="blx" min="0" max="100" value="0">
                <label for="bly">Bottom Left Y</label>
                <input type="range" id="bly" min="0" max="100" value="100">
            </div>
        </div>

        <div class="controls-container">
            <div class="flex items-center justify-center gap-2">
                 <button id="webcamButton" class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold py-2 px-4 text-sm rounded-full shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                    Enable Webcam
                </button>
                <button id="toggleBgButton" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 text-sm rounded-full shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out" style="display: none;">
                    Show Webcam
                </button>
                <select id="cameraSelector" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 text-sm rounded-full shadow-lg" style="display: none; pointer-events: auto;"></select>
                <button id="fullscreenButton" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 text-sm rounded-full shadow-lg transform hover:scale-105 transition-transform duration-300 ease-in-out">
                    Fullscreen
                </button>
            </div>
             <div id="loading" class="text-gray-400 mt-4" style="display: none;">
                <svg class="animate-spin h-5 w-5 mr-3 inline-block" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Loading AI Model...
            </div>
        </div>
    </div>

    <!-- This button is outside the main UI overlay so it doesn't get hidden -->
    <button id="toggleUiButton" class="bg-gray-800 bg-opacity-50 hover:bg-opacity-75 text-white font-semibold py-1 px-3 rounded-full shadow-lg text-xs">
        Hide UI
    </button>

    <!-- MediaPipe Vision Tasks -->
    <script type="module">
        import {
            PoseLandmarker,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // Get DOM elements
        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const webcamButton = document.getElementById("webcamButton");
        const loadingElement = document.getElementById("loading");
        const liveView = document.getElementById("liveView");
        const toggleBgButton = document.getElementById("toggleBgButton");
        const perspectiveControls = document.getElementById("perspective-controls");
        const cameraSelector = document.getElementById("cameraSelector");
        const toggleUiButton = document.getElementById("toggleUiButton");
        const controlsContainer = document.querySelector(".controls-container");
        const fullscreenButton = document.getElementById("fullscreenButton");

        let poseLandmarker = undefined;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        let drawingUtils;
        let lastVideoTime = -1;
        let smoothedLandmarks; // Variable to store the smoothed landmark data
        let isWebcamBackground = false; // State for background toggle
        let listenerAdded = false;
        let isUiVisible = true;

        // --- 1. COOKIE HELPER FUNCTIONS ---
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/; SameSite=Lax";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        // --- 1B. INITIALIZE THE MODEL ---
        const createPoseLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    // Use a lighter model for better performance on the web
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numPoses: 1 // Track a single person for this demo
            });
            drawingUtils = new DrawingUtils(canvasCtx);
            
            // Hide loading and enable the button once the model is ready
            loadingElement.style.display = 'none';
            webcamButton.disabled = false;
            console.log("PoseLandmarker model loaded.");
        };

        // Show loading and start creating the model
        webcamButton.disabled = true;
        loadingElement.style.display = 'block';
        createPoseLandmarker();
        
        // --- 2. WEBCAM AND CONTROLS LOGIC ---
        
        // Populates the camera selector dropdown.
        async function populateCameraSelector() {
            cameraSelector.innerHTML = ''; // Clear existing options
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                if (videoDevices.length === 0) throw new Error("No camera devices found.");
                
                videoDevices.forEach((device, i) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.innerText = device.label || `Camera ${i + 1}`;
                    cameraSelector.appendChild(option);
                });
                cameraSelector.style.display = 'inline-block';
            } catch (err) {
                console.error("Could not enumerate devices:", err);
                cameraSelector.style.display = 'none';
            }
        }

        // Starts the webcam stream with a given device ID.
        function startStreamFromSelector() {
            const deviceId = cameraSelector.value;

            // Load saved settings for this camera from cookies
            loadSettingsForCamera(deviceId);
            // Instantly apply the loaded settings
            if (webcamRunning) applyPerspectiveTransform();

            const constraints = deviceId ? { video: { deviceId: { exact: deviceId } } } : { video: true };

            // Stop any previous stream.
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                // Add the listener for when video data is loaded, but only once.
                if (!listenerAdded) {
                    video.addEventListener("loadeddata", startPredictionLoop);
                    listenerAdded = true;
                }
            }).catch((err) => {
                console.error("Error accessing webcam: ", err);
                webcamRunning = false;
                webcamButton.innerText = "Enable Webcam";
            });
        }

        const enableCam = async (event) => {
            if (!poseLandmarker) {
                console.log("Wait! poseLandmarker not loaded yet.");
                return;
            }

            if (webcamRunning) {
                webcamRunning = false;
                webcamButton.innerText = "Enable Webcam";
                video.pause();
                if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                smoothedLandmarks = undefined;
                toggleBgButton.style.display = 'none';
                perspectiveControls.style.display = 'none';
                cameraSelector.style.display = 'none';
                toggleUiButton.style.display = 'none';
                video.style.display = 'none';
                isWebcamBackground = false;
            } else {
                webcamRunning = true;
                webcamButton.innerText = "Disable Webcam";
                toggleUiButton.style.display = 'block';
                // Only show the main controls if the UI is not hidden
                if(isUiVisible) {
                    toggleBgButton.style.display = 'inline-block';
                    perspectiveControls.style.display = 'block';
                }
                toggleBgButton.innerText = 'Show Webcam';
                
                await populateCameraSelector();
                startStreamFromSelector();
            }
        };

        webcamButton.addEventListener("click", enableCam);
        cameraSelector.addEventListener('change', () => {
            if (webcamRunning) startStreamFromSelector();
        });

        toggleBgButton.addEventListener("click", () => {
            isWebcamBackground = !isWebcamBackground;
            if (isWebcamBackground) {
                video.style.display = 'block';
                toggleBgButton.innerText = 'Hide Webcam';
            } else {
                video.style.display = 'none';
                toggleBgButton.innerText = 'Show Webcam';
            }
        });

        toggleUiButton.addEventListener('click', () => {
            isUiVisible = !isUiVisible;
            if (isUiVisible) {
                perspectiveControls.style.display = 'block';
                controlsContainer.style.display = 'block'; // Or 'flex' if it was a flex container
                toggleUiButton.innerText = 'Hide UI';
            } else {
                perspectiveControls.style.display = 'none';
                controlsContainer.style.display = 'none';
                toggleUiButton.innerText = 'Show UI';
            }
        });

        fullscreenButton.addEventListener('click', () => {
            const doc = window.document;
            const docEl = doc.documentElement;

            const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

            if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
                requestFullScreen.call(docEl);
            } else {
                cancelFullScreen.call(doc);
            }
        });

        // Handles changes in fullscreen state (e.g., user pressing ESC)
        function handleFullscreenChange() {
            const doc = window.document;
            if (doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement) {
                fullscreenButton.innerText = 'Exit Fullscreen';
            } else {
                fullscreenButton.innerText = 'Fullscreen';
            }
        }

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);


        // --- 3. PREDICTION LOOP ---
        const startPredictionLoop = () => {
            // Set canvas size to match video feed ONCE per new stream
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;
            applyPerspectiveTransform();
            predictWebcam();
        }

        const predictWebcam = async () => {
            if (video.videoWidth === 0 || video.videoHeight === 0) {
                if (webcamRunning) window.requestAnimationFrame(predictWebcam);
                return;
            }

            const smoothingFactor = 0.25;
            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
                    canvasCtx.save();
                    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                    if (!isWebcamBackground) {
                        canvasCtx.fillStyle = "black";
                        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                    }

                    if (result.landmarks && result.landmarks.length > 0) {
                        const newLandmarks = result.landmarks[0];

                        if (!smoothedLandmarks) {
                            smoothedLandmarks = JSON.parse(JSON.stringify(newLandmarks));
                        } else {
                            for (let i = 0; i < newLandmarks.length; i++) {
                                smoothedLandmarks[i].x = smoothingFactor * newLandmarks[i].x + (1 - smoothingFactor) * smoothedLandmarks[i].x;
                                smoothedLandmarks[i].y = smoothingFactor * newLandmarks[i].y + (1 - smoothingFactor) * smoothedLandmarks[i].y;
                                smoothedLandmarks[i].z = smoothingFactor * newLandmarks[i].z + (1 - smoothingFactor) * smoothedLandmarks[i].z;
                                smoothedLandmarks[i].visibility = newLandmarks[i].visibility;
                            }
                        }

                        drawingUtils.drawLandmarks(smoothedLandmarks, {
                            radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1),
                            color: '#FFFFFF'
                        });
                        drawingUtils.drawConnectors(smoothedLandmarks, PoseLandmarker.POSE_CONNECTIONS, {
                            color: `rgb(120,0,0)`,
                            lineWidth: 8
                        });
                    }
                    canvasCtx.restore();
                });
            }

            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        };

        // --- 4. PERSPECTIVE AND SETTINGS LOGIC ---

        function saveSettingsForCurrentCamera() {
            if (!webcamRunning) return;
            const deviceId = cameraSelector.value;
            if (!deviceId) return;

            const settings = {
                tlx: document.getElementById('tlx').value,
                tly: document.getElementById('tly').value,
                trx: document.getElementById('trx').value,
                try: document.getElementById('try').value,
                brx: document.getElementById('brx').value,
                bry: document.getElementById('bry').value,
                blx: document.getElementById('blx').value,
                bly: document.getElementById('bly').value,
            };
            
            setCookie(`perspective_settings_${deviceId}`, JSON.stringify(settings), 365);
        }

        function loadSettingsForCamera(deviceId) {
            if (!deviceId) return;
            const cookie = getCookie(`perspective_settings_${deviceId}`);
            if (cookie) {
                try {
                    const settings = JSON.parse(cookie);
                    document.getElementById('tlx').value = settings.tlx;
                    document.getElementById('tly').value = settings.tly;
                    document.getElementById('trx').value = settings.trx;
                    document.getElementById('try').value = settings.try;
                    document.getElementById('brx').value = settings.brx;
                    document.getElementById('bry').value = settings.bry;
                    document.getElementById('blx').value = settings.blx;
                    document.getElementById('bly').value = settings.bly;
                } catch (e) {
                    console.error("Failed to parse perspective settings from cookie:", e);
                }
            }
        }

        const applyPerspectiveTransform = () => {
             if (!webcamRunning) return;
            const w = liveView.clientWidth;
            const h = liveView.clientHeight;
            const srcPts = [ { x: 0, y: 0 }, { x: w, y: 0 }, { x: w, y: h }, { x: 0, y: h } ];
            const dstPts = [
                { x: w * (parseInt(document.getElementById('tlx').value) / 100), y: h * (parseInt(document.getElementById('tly').value) / 100) },
                { x: w * (parseInt(document.getElementById('trx').value) / 100), y: h * (parseInt(document.getElementById('try').value) / 100) },
                { x: w * (parseInt(document.getElementById('brx').value) / 100), y: h * (parseInt(document.getElementById('bry').value) / 100) },
                { x: w * (parseInt(document.getElementById('blx').value) / 100), y: h * (parseInt(document.getElementById('bly').value) / 100) }
            ];
            const transformMatrix = getTransform(srcPts, dstPts);
            canvasElement.style.transform = transformMatrix;
        }
        
        window.addEventListener('resize', applyPerspectiveTransform);
        
        // Add event listeners to all sliders to update the transform and save settings on change
        document.querySelectorAll('#perspective-controls input[type="range"]').forEach(slider => {
            slider.addEventListener('input', () => {
                applyPerspectiveTransform();
                saveSettingsForCurrentCamera();
            });
        });

        function getTransform(srcPts, dstPts) {
            const A = new Array(8).fill(0).map(() => new Array(8).fill(0));
            const b = new Array(8);
            for (let i = 0; i < 4; i++) {
                const sp = srcPts[i];
                const dp = dstPts[i];
                A[i*2][0] = A[i*2+1][3] = sp.x;
                A[i*2][1] = A[i*2+1][4] = sp.y;
                A[i*2][2] = A[i*2+1][5] = 1;
                A[i*2][6] = -sp.x * dp.x;
                A[i*2][7] = -sp.y * dp.x;
                A[i*2+1][6] = -sp.x * dp.y;
                A[i*2+1][7] = -sp.y * dp.y;
                b[i*2] = dp.x;
                b[i*2+1] = dp.y;
            }
            const h = gaussianElimination(A, b);
            const matrix = [
                h[0], h[3], 0, h[6],
                h[1], h[4], 0, h[7],
                0   , 0   , 1, 0,
                h[2], h[5], 0, 1
            ];
            return `matrix3d(${matrix.join(',')})`;
        }

        function gaussianElimination(A, b) {
            const n = A.length;
            for (let i = 0; i < n; i++) {
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) maxRow = k;
                }
                [A[i], A[maxRow]] = [A[maxRow], A[i]];
                [b[i], b[maxRow]] = [b[maxRow], b[i]];
                for (let k = i + 1; k < n; k++) {
                    const factor = A[k][i] / A[i][i];
                    if (isFinite(factor)) {
                         for (let j = i; j < n; j++) A[k][j] -= factor * A[i][j];
                        b[k] -= factor * b[i];
                    }
                }
            }
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += A[i][j] * x[j];
                x[i] = (b[i] - sum) / A[i][i];
            }
            return x.map(val => isFinite(val) ? val : 0);
        }
    </script>
</body>
</html>







