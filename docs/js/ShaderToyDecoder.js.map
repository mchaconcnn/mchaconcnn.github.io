{
  "version": 3,
  "sources": ["../../js/examples/jsm/transpiler/AST.js", "../../js/examples/jsm/transpiler/GLSLDecoder.js", "../../js/examples/jsm/transpiler/ShaderToyDecoder.js"],
  "sourcesContent": ["export class Program {\n\n\tconstructor() {\n\n\t\tthis.body = [];\n\n\t\tthis.isProgram = true;\n\n\t}\n\n}\n\nexport class VariableDeclaration {\n\n\tconstructor( type, name, value = null, next = null, immutable = false ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t\tthis.next = next;\n\n\t\tthis.immutable = immutable;\n\n\t\tthis.isVariableDeclaration = true;\n\n\t}\n\n}\n\nexport class Uniform {\n\n\tconstructor( type, name ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\n\t\tthis.isUniform = true;\n\n\t}\n\n}\n\nexport class Varying {\n\n\tconstructor( type, name ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\n\t\tthis.isVarying = true;\n\n\t}\n\n}\n\nexport class FunctionParameter {\n\n\tconstructor( type, name, qualifier = null, immutable = true ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.qualifier = qualifier;\n\t\tthis.immutable = immutable;\n\n\t\tthis.isFunctionParameter = true;\n\n\t}\n\n}\n\nexport class FunctionDeclaration {\n\n\tconstructor( type, name, params = [] ) {\n\n\t\tthis.type = type;\n\t\tthis.name = name;\n\t\tthis.params = params;\n\t\tthis.body = [];\n\n\t\tthis.isFunctionDeclaration = true;\n\n\t}\n\n}\n\nexport class Expression {\n\n\tconstructor( expression ) {\n\n\t\tthis.expression = expression;\n\n\t\tthis.isExpression = true;\n\n\t}\n\n}\n\nexport class Ternary {\n\n\tconstructor( cond, left, right ) {\n\n\t\tthis.cond = cond;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\n\t\tthis.isTernary = true;\n\n\t}\n\n}\n\nexport class Operator {\n\n\tconstructor( type, left, right ) {\n\n\t\tthis.type = type;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\n\t\tthis.isOperator = true;\n\n\t}\n\n}\n\n\nexport class Unary {\n\n\tconstructor( type, expression, after = false ) {\n\n\t\tthis.type = type;\n\t\tthis.expression = expression;\n\t\tthis.after = after;\n\n\t\tthis.isUnary = true;\n\n\t}\n\n}\n\nexport class Number {\n\n\tconstructor( value, type = 'float' ) {\n\n\t\tthis.type = type;\n\t\tthis.value = value;\n\n\t\tthis.isNumber = true;\n\n\t}\n\n}\n\nexport class String {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t\tthis.isString = true;\n\n\t}\n\n}\n\n\nexport class Conditional {\n\n\tconstructor( cond = null ) {\n\n\t\tthis.cond = cond;\n\n\t\tthis.body = [];\n\t\tthis.elseConditional = null;\n\n\t\tthis.isConditional = true;\n\n\t}\n\n}\n\nexport class FunctionCall {\n\n\tconstructor( name, params = [] ) {\n\n\t\tthis.name = name;\n\t\tthis.params = params;\n\n\t\tthis.isFunctionCall = true;\n\n\t}\n\n}\n\nexport class Return {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t\tthis.isReturn = true;\n\n\t}\n\n}\n\nexport class Discard {\n\n\tconstructor() {\n\n\t\tthis.isDiscard = true;\n\n\t}\n\n}\n\nexport class Accessor {\n\n\tconstructor( property ) {\n\n\t\tthis.property = property;\n\n\t\tthis.isAccessor = true;\n\n\t}\n\n}\n\nexport class StaticElement {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t\tthis.isStaticElement = true;\n\n\t}\n\n}\n\nexport class DynamicElement {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t\tthis.isDynamicElement = true;\n\n\t}\n\n}\n\nexport class AccessorElements {\n\n\tconstructor( object, elements = [] ) {\n\n\t\tthis.object = object;\n\t\tthis.elements = elements;\n\n\t\tthis.isAccessorElements = true;\n\n\t}\n\n}\n\nexport class For {\n\n\tconstructor( initialization, condition, afterthought ) {\n\n\t\tthis.initialization = initialization;\n\t\tthis.condition = condition;\n\t\tthis.afterthought = afterthought;\n\n\t\tthis.body = [];\n\n\t\tthis.isFor = true;\n\n\t}\n\n}\n", "import { Program, FunctionDeclaration, For, AccessorElements, Ternary, Varying, DynamicElement, StaticElement, FunctionParameter, Unary, Conditional, VariableDeclaration, Operator, Number, String, FunctionCall, Return, Accessor, Uniform, Discard } from './AST.js';\n\nconst unaryOperators = [\n\t'+', '-', '~', '!', '++', '--'\n];\n\nconst precedenceOperators = [\n\t'*', '/', '%',\n\t'-', '+',\n\t'<<', '>>',\n\t'<', '>', '<=', '>=',\n\t'==', '!=',\n\t'&',\n\t'^',\n\t'|',\n\t'&&',\n\t'^^',\n\t'||',\n\t'?',\n\t'=',\n\t'+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',\n\t','\n].reverse();\n\nconst associativityRightToLeft = [\n\t'=',\n\t'+=', '-=', '*=', '/=', '%=', '^=', '&=', '|=', '<<=', '>>=',\n\t',',\n\t'?',\n\t':'\n];\n\nconst glslToTSL = {\n\tinversesqrt: 'inverseSqrt'\n};\n\nconst samplers = [ 'sampler1D', 'sampler2D', 'sampler2DArray', 'sampler2DShadow', 'sampler2DArrayShadow', 'isampler2D', 'isampler2DArray', 'usampler2D', 'usampler2DArray' ];\nconst samplersCube = [ 'samplerCube', 'samplerCubeShadow', 'usamplerCube', 'isamplerCube' ];\nconst samplers3D = [ 'sampler3D', 'isampler3D', 'usampler3D' ];\n\nconst spaceRegExp = /^((\\t| )\\n*)+/;\nconst lineRegExp = /^\\n+/;\nconst commentRegExp = /^\\/\\*[\\s\\S]*?\\*\\//;\nconst inlineCommentRegExp = /^\\/\\/.*?(\\n|$)/;\n\nconst numberRegExp = /^((0x\\w+)|(\\.?\\d+\\.?\\d*((e-?\\d+)|\\w)?))/;\nconst stringDoubleRegExp = /^(\\\"((?:[^\"\\\\]|\\\\.)*)\\\")/;\nconst stringSingleRegExp = /^(\\'((?:[^'\\\\]|\\\\.)*)\\')/;\nconst literalRegExp = /^[A-Za-z](\\w|\\.)*/;\nconst operatorsRegExp = new RegExp( '^(\\\\' + [\n\t'<<=', '>>=', '++', '--', '<<', '>>', '+=', '-=', '*=', '/=', '%=', '&=', '^^', '^=', '|=',\n\t'<=', '>=', '==', '!=', '&&', '||',\n\t'(', ')', '[', ']', '{', '}',\n\t'.', ',', ';', '!', '=', '~', '*', '/', '%', '+', '-', '<', '>', '&', '^', '|', '?', ':', '#'\n].join( '$' ).split( '' ).join( '\\\\' ).replace( /\\\\\\$/g, '|' ) + ')' );\n\nfunction getFunctionName( str ) {\n\n\treturn glslToTSL[ str ] || str;\n\n}\n\nfunction getGroupDelta( str ) {\n\n\tif ( str === '(' || str === '[' || str === '{' ) return 1;\n\tif ( str === ')' || str === ']' || str === '}' ) return - 1;\n\n\treturn 0;\n\n}\n\nclass Token {\n\n\tconstructor( tokenizer, type, str, pos ) {\n\n\t\tthis.tokenizer = tokenizer;\n\n\t\tthis.type = type;\n\n\t\tthis.str = str;\n\t\tthis.pos = pos;\n\n\t\tthis.tag = null;\n\n\t}\n\n\tget endPos() {\n\n\t\treturn this.pos + this.str.length;\n\n\t}\n\n\tget isNumber() {\n\n\t\treturn this.type === Token.NUMBER;\n\n\t}\n\n\tget isString() {\n\n\t\treturn this.type === Token.STRING;\n\n\t}\n\n\tget isLiteral() {\n\n\t\treturn this.type === Token.LITERAL;\n\n\t}\n\n\tget isOperator() {\n\n\t\treturn this.type === Token.OPERATOR;\n\n\t}\n\n}\n\nToken.LINE = 'line';\nToken.COMMENT = 'comment';\nToken.NUMBER = 'number';\nToken.STRING = 'string';\nToken.LITERAL = 'literal';\nToken.OPERATOR = 'operator';\n\nconst TokenParserList = [\n\t{ type: Token.LINE, regexp: lineRegExp, isTag: true },\n\t{ type: Token.COMMENT, regexp: commentRegExp, isTag: true },\n\t{ type: Token.COMMENT, regexp: inlineCommentRegExp, isTag: true },\n\t{ type: Token.NUMBER, regexp: numberRegExp },\n\t{ type: Token.STRING, regexp: stringDoubleRegExp, group: 2 },\n\t{ type: Token.STRING, regexp: stringSingleRegExp, group: 2 },\n\t{ type: Token.LITERAL, regexp: literalRegExp },\n\t{ type: Token.OPERATOR, regexp: operatorsRegExp }\n];\n\nclass Tokenizer {\n\n\tconstructor( source ) {\n\n\t\tthis.source = source;\n\t\tthis.position = 0;\n\n\t\tthis.tokens = [];\n\n\t}\n\n\ttokenize() {\n\n\t\tlet token = this.readToken();\n\n\t\twhile ( token ) {\n\n\t\t\tthis.tokens.push( token );\n\n\t\t\ttoken = this.readToken();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tskip( ...params ) {\n\n\t\tlet remainingCode = this.source.substr( this.position );\n\t\tlet i = params.length;\n\n\t\twhile ( i -- ) {\n\n\t\t\tconst skip = params[ i ].exec( remainingCode );\n\t\t\tconst skipLength = skip ? skip[ 0 ].length : 0;\n\n\t\t\tif ( skipLength > 0 ) {\n\n\t\t\t\tthis.position += skipLength;\n\n\t\t\t\tremainingCode = this.source.substr( this.position );\n\n\t\t\t\t// re-skip, new remainingCode is generated\n\t\t\t\t// maybe exist previous regexp non detected\n\t\t\t\ti = params.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn remainingCode;\n\n\t}\n\n\treadToken() {\n\n\t\tconst remainingCode = this.skip( spaceRegExp );\n\n\t\tfor ( var i = 0; i < TokenParserList.length; i ++ ) {\n\n\t\t\tconst parser = TokenParserList[ i ];\n\t\t\tconst result = parser.regexp.exec( remainingCode );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tconst token = new Token( this, parser.type, result[ parser.group || 0 ], this.position );\n\n\t\t\t\tthis.position += result[ 0 ].length;\n\n\t\t\t\tif ( parser.isTag ) {\n\n\t\t\t\t\tconst nextToken = this.readToken();\n\n\t\t\t\t\tif ( nextToken ) {\n\n\t\t\t\t\t\tnextToken.tag = token;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nextToken;\n\n\t\t\t\t}\n\n\t\t\t\treturn token;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst isType = ( str ) => /void|bool|float|u?int|mat[234]|mat[234]x[234]|(u|i|b)?vec[234]/.test( str );\n\nclass GLSLDecoder {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.tokenizer = null;\n\t\tthis.keywords = [];\n\n\t\tthis._currentFunction = null;\n\n\t\tthis.addPolyfill( 'gl_FragCoord', 'vec3 gl_FragCoord = vec3( screenCoordinate.x, screenCoordinate.y.oneMinus(), screenCoordinate.z );' );\n\n\t}\n\n\taddPolyfill( name, polyfill ) {\n\n\t\tthis.keywords.push( { name, polyfill } );\n\n\t\treturn this;\n\n\t}\n\n\tget tokens() {\n\n\t\treturn this.tokenizer.tokens;\n\n\t}\n\n\treadToken() {\n\n\t\treturn this.tokens[ this.index ++ ];\n\n\t}\n\n\tgetToken( offset = 0 ) {\n\n\t\treturn this.tokens[ this.index + offset ];\n\n\t}\n\n\tgetTokensUntil( str, tokens, offset = 0 ) {\n\n\t\tconst output = [];\n\n\t\tlet groupIndex = 0;\n\n\t\tfor ( let i = offset; i < tokens.length; i ++ ) {\n\n\t\t\tconst token = tokens[ i ];\n\n\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\toutput.push( token );\n\n\t\t\tif ( groupIndex === 0 && token.str === str ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\treadTokensUntil( str ) {\n\n\t\tconst tokens = this.getTokensUntil( str, this.tokens, this.index );\n\n\t\tthis.index += tokens.length;\n\n\t\treturn tokens;\n\n\t}\n\n\tparseExpressionFromTokens( tokens ) {\n\n\t\tif ( tokens.length === 0 ) return null;\n\n\t\tconst firstToken = tokens[ 0 ];\n\t\tconst lastToken = tokens[ tokens.length - 1 ];\n\n\t\t// precedence operators\n\n\t\tlet groupIndex = 0;\n\n\t\tfor ( const operator of precedenceOperators ) {\n\n\t\t\tconst parseToken = ( i, inverse = false ) => {\n\n\t\t\t\tconst token = tokens[ i ];\n\n\t\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\t\tif ( ! token.isOperator || i === 0 || i === tokens.length - 1 ) return;\n\n\t\t\t\tif ( groupIndex === 0 && token.str === operator ) {\n\n\t\t\t\t\tif ( operator === '?' ) {\n\n\t\t\t\t\t\tconst conditionTokens = tokens.slice( 0, i );\n\t\t\t\t\t\tconst leftTokens = this.getTokensUntil( ':', tokens, i + 1 ).slice( 0, - 1 );\n\t\t\t\t\t\tconst rightTokens = tokens.slice( i + leftTokens.length + 2 );\n\n\t\t\t\t\t\tconst condition = this.parseExpressionFromTokens( conditionTokens );\n\t\t\t\t\t\tconst left = this.parseExpressionFromTokens( leftTokens );\n\t\t\t\t\t\tconst right = this.parseExpressionFromTokens( rightTokens );\n\n\t\t\t\t\t\treturn new Ternary( condition, left, right );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst left = this.parseExpressionFromTokens( tokens.slice( 0, i ) );\n\t\t\t\t\t\tconst right = this.parseExpressionFromTokens( tokens.slice( i + 1, tokens.length ) );\n\n\t\t\t\t\t\treturn this._evalOperator( new Operator( operator, left, right ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( inverse ) {\n\n\t\t\t\t\tif ( groupIndex > 0 ) {\n\n\t\t\t\t\t\treturn this.parseExpressionFromTokens( tokens.slice( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( groupIndex < 0 ) {\n\n\t\t\t\t\t\treturn this.parseExpressionFromTokens( tokens.slice( 0, i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tif ( associativityRightToLeft.includes( operator ) ) {\n\n\t\t\t\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\t\t\t\tconst result = parseToken( i );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = tokens.length - 1; i >= 0; i -- ) {\n\n\t\t\t\t\tconst result = parseToken( i, true );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// unary operators (before)\n\n\t\tif ( firstToken.isOperator ) {\n\n\t\t\tfor ( const operator of unaryOperators ) {\n\n\t\t\t\tif ( firstToken.str === operator ) {\n\n\t\t\t\t\tconst right = this.parseExpressionFromTokens( tokens.slice( 1 ) );\n\n\t\t\t\t\treturn new Unary( operator, right );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// unary operators (after)\n\n\t\tif ( lastToken.isOperator ) {\n\n\t\t\tfor ( const operator of unaryOperators ) {\n\n\t\t\t\tif ( lastToken.str === operator ) {\n\n\t\t\t\t\tconst left = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );\n\n\t\t\t\t\treturn new Unary( operator, left, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// groups\n\n\t\tif ( firstToken.str === '(' ) {\n\n\t\t\tconst leftTokens = this.getTokensUntil( ')', tokens );\n\n\t\t\tconst left = this.parseExpressionFromTokens( leftTokens.slice( 1, leftTokens.length - 1 ) );\n\n\t\t\tconst operator = tokens[ leftTokens.length ];\n\n\t\t\tif ( operator ) {\n\n\t\t\t\tconst rightTokens = tokens.slice( leftTokens.length + 1 );\n\t\t\t\tconst right = this.parseExpressionFromTokens( rightTokens );\n\n\t\t\t\treturn this._evalOperator( new Operator( operator.str, left, right ) );\n\n\t\t\t}\n\n\t\t\treturn left;\n\n\t\t}\n\n\t\t// primitives and accessors\n\n\t\tif ( firstToken.isNumber ) {\n\n\t\t\tlet type;\n\n\t\t\tconst isHex = /^(0x)/.test( firstToken.str );\n\n\t\t\tif ( isHex ) type = 'int';\n\t\t\telse if ( /u$|U$/.test( firstToken.str ) ) type = 'uint';\n\t\t\telse if ( /f|e|\\./.test( firstToken.str ) ) type = 'float';\n\t\t\telse type = 'int';\n\n\t\t\tlet str = firstToken.str.replace( /u|U|i$/, '' );\n\n\t\t\tif ( isHex === false ) {\n\n\t\t\t\tstr = str.replace( /f$/, '' );\n\n\t\t\t}\n\n\t\t\treturn new Number( str, type );\n\n\t\t} else if ( firstToken.isString ) {\n\n\t\t\treturn new String( firstToken.str );\n\n\t\t} else if ( firstToken.isLiteral ) {\n\n\t\t\tif ( firstToken.str === 'return' ) {\n\n\t\t\t\treturn new Return( this.parseExpressionFromTokens( tokens.slice( 1 ) ) );\n\n\t\t\t} else if ( firstToken.str === 'discard' ) {\n\n\t\t\t\treturn new Discard();\n\n\t\t\t}\n\n\t\t\tconst secondToken = tokens[ 1 ];\n\n\t\t\tif ( secondToken ) {\n\n\t\t\t\tif ( secondToken.str === '(' ) {\n\n\t\t\t\t\t// function call\n\n\t\t\t\t\tconst internalTokens = this.getTokensUntil( ')', tokens, 1 ).slice( 1, - 1 );\n\n\t\t\t\t\tconst paramsTokens = this.parseFunctionParametersFromTokens( internalTokens );\n\n\t\t\t\t\tconst functionCall = new FunctionCall( getFunctionName( firstToken.str ), paramsTokens );\n\n\t\t\t\t\tconst accessTokens = tokens.slice( 3 + internalTokens.length );\n\n\t\t\t\t\tif ( accessTokens.length > 0 ) {\n\n\t\t\t\t\t\tconst elements = this.parseAccessorElementsFromTokens( accessTokens );\n\n\t\t\t\t\t\treturn new AccessorElements( functionCall, elements );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn functionCall;\n\n\t\t\t\t} else if ( secondToken.str === '[' ) {\n\n\t\t\t\t\t// array accessor\n\n\t\t\t\t\tconst elements = this.parseAccessorElementsFromTokens( tokens.slice( 1 ) );\n\n\t\t\t\t\treturn new AccessorElements( new Accessor( firstToken.str ), elements );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Accessor( firstToken.str );\n\n\t\t}\n\n\t}\n\n\tparseAccessorElementsFromTokens( tokens ) {\n\n\t\tconst elements = [];\n\n\t\tlet currentTokens = tokens;\n\n\t\twhile ( currentTokens.length > 0 ) {\n\n\t\t\tconst token = currentTokens[ 0 ];\n\n\t\t\tif ( token.str === '[' ) {\n\n\t\t\t\tconst accessorTokens = this.getTokensUntil( ']', currentTokens );\n\n\t\t\t\tconst element = this.parseExpressionFromTokens( accessorTokens.slice( 1, accessorTokens.length - 1 ) );\n\n\t\t\t\tcurrentTokens = currentTokens.slice( accessorTokens.length );\n\n\t\t\t\telements.push( new DynamicElement( element ) );\n\n\t\t\t} else if ( token.str === '.' ) {\n\n\t\t\t\tconst accessorTokens = currentTokens.slice( 1, 2 );\n\n\t\t\t\tconst element = this.parseExpressionFromTokens( accessorTokens );\n\n\t\t\t\tcurrentTokens = currentTokens.slice( 2 );\n\n\t\t\t\telements.push( new StaticElement( element ) );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'Unknown accessor expression', token );\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn elements;\n\n\t}\n\n\tparseFunctionParametersFromTokens( tokens ) {\n\n\t\tif ( tokens.length === 0 ) return [];\n\n\t\tconst expression = this.parseExpressionFromTokens( tokens );\n\t\tconst params = [];\n\n\t\tlet current = expression;\n\n\t\twhile ( current.type === ',' ) {\n\n\t\t\tparams.push( current.left );\n\n\t\t\tcurrent = current.right;\n\n\t\t}\n\n\t\tparams.push( current );\n\n\t\treturn params;\n\n\t}\n\n\tparseExpression() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tconst exp = this.parseExpressionFromTokens( tokens.slice( 0, tokens.length - 1 ) );\n\n\t\treturn exp;\n\n\t}\n\n\tparseFunctionParams( tokens ) {\n\n\t\tconst params = [];\n\n\t\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\t\tconst immutable = tokens[ i ].str === 'const';\n\t\t\tif ( immutable ) i ++;\n\n\t\t\tlet qualifier = tokens[ i ].str;\n\n\t\t\tif ( /^(in|out|inout)$/.test( qualifier ) ) {\n\n\t\t\t\ti ++;\n\n\t\t\t} else {\n\n\t\t\t\tqualifier = null;\n\n\t\t\t}\n\n\t\t\tconst type = tokens[ i ++ ].str;\n\t\t\tconst name = tokens[ i ++ ].str;\n\n\t\t\tparams.push( new FunctionParameter( type, name, qualifier, immutable ) );\n\n\t\t\tif ( tokens[ i ] && tokens[ i ].str !== ',' ) throw new Error( 'Expected \",\"' );\n\n\t\t}\n\n\t\treturn params;\n\n\t}\n\n\tparseFunction() {\n\n\t\tconst type = this.readToken().str;\n\t\tconst name = this.readToken().str;\n\n\t\tconst paramsTokens = this.readTokensUntil( ')' );\n\n\t\tconst params = this.parseFunctionParams( paramsTokens.slice( 1, paramsTokens.length - 1 ) );\n\n\t\tconst func = new FunctionDeclaration( type, name, params );\n\n\t\tthis._currentFunction = func;\n\n\t\tthis.parseBlock( func );\n\n\t\tthis._currentFunction = null;\n\n\t\treturn func;\n\n\t}\n\n\tparseVariablesFromToken( tokens, type ) {\n\n\t\tlet index = 0;\n\t\tconst immutable = tokens[ 0 ].str === 'const';\n\n\t\tif ( immutable ) index ++;\n\n\t\ttype = type || tokens[ index ++ ].str;\n\t\tconst name = tokens[ index ++ ].str;\n\n\t\tconst token = tokens[ index ];\n\n\t\tlet init = null;\n\t\tlet next = null;\n\n\t\tif ( token ) {\n\n\t\t\tconst initTokens = this.getTokensUntil( ',', tokens, index );\n\n\t\t\tif ( initTokens[ 0 ].str === '=' ) {\n\n\t\t\t\tconst expressionTokens = initTokens.slice( 1 );\n\t\t\t\tif ( expressionTokens[ expressionTokens.length - 1 ].str === ',' ) expressionTokens.pop();\n\n\t\t\t\tinit = this.parseExpressionFromTokens( expressionTokens );\n\n\t\t\t}\n\n\t\t\tconst nextTokens = tokens.slice( initTokens.length + ( index - 1 ) );\n\n\t\t\tif ( nextTokens[ 0 ] && nextTokens[ 0 ].str === ',' ) {\n\n\t\t\t\tnext = this.parseVariablesFromToken( nextTokens.slice( 1 ), type );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst variable = new VariableDeclaration( type, name, init, next, immutable );\n\n\t\treturn variable;\n\n\t}\n\n\tparseVariables() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\treturn this.parseVariablesFromToken( tokens.slice( 0, tokens.length - 1 ) );\n\n\t}\n\n\tparseUniform() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tlet type = tokens[ 1 ].str;\n\t\tconst name = tokens[ 2 ].str;\n\n\t\t// GLSL to TSL types\n\n\t\tif ( samplers.includes( type ) ) type = 'texture';\n\t\telse if ( samplersCube.includes( type ) ) type = 'cubeTexture';\n\t\telse if ( samplers3D.includes( type ) ) type = 'texture3D';\n\n\t\treturn new Uniform( type, name );\n\n\t}\n\n\tparseVarying() {\n\n\t\tconst tokens = this.readTokensUntil( ';' );\n\n\t\tconst type = tokens[ 1 ].str;\n\t\tconst name = tokens[ 2 ].str;\n\n\t\treturn new Varying( type, name );\n\n\t}\n\n\tparseReturn() {\n\n\t\tthis.readToken(); // skip 'return'\n\n\t\tconst expression = this.parseExpression();\n\n\t\treturn new Return( expression );\n\n\t}\n\n\tparseFor() {\n\n\t\tthis.readToken(); // skip 'for'\n\n\t\tconst forTokens = this.readTokensUntil( ')' ).slice( 1, - 1 );\n\n\t\tconst initializationTokens = this.getTokensUntil( ';', forTokens, 0 ).slice( 0, - 1 );\n\t\tconst conditionTokens = this.getTokensUntil( ';', forTokens, initializationTokens.length + 1 ).slice( 0, - 1 );\n\t\tconst afterthoughtTokens = forTokens.slice( initializationTokens.length + conditionTokens.length + 2 );\n\n\t\tlet initialization;\n\n\t\tif ( initializationTokens[ 0 ] && isType( initializationTokens[ 0 ].str ) ) {\n\n\t\t\tinitialization = this.parseVariablesFromToken( initializationTokens );\n\n\t\t} else {\n\n\t\t\tinitialization = this.parseExpressionFromTokens( initializationTokens );\n\n\t\t}\n\n\t\tconst condition = this.parseExpressionFromTokens( conditionTokens );\n\t\tconst afterthought = this.parseExpressionFromTokens( afterthoughtTokens );\n\n\t\tconst statement = new For( initialization, condition, afterthought );\n\n\t\tif ( this.getToken().str === '{' ) {\n\n\t\t\tthis.parseBlock( statement );\n\n\t\t} else {\n\n\t\t\tstatement.body.push( this.parseExpression() );\n\n\t\t}\n\n\t\treturn statement;\n\n\t}\n\n\tparseIf() {\n\n\t\tconst parseIfExpression = () => {\n\n\t\t\tthis.readToken(); // skip 'if'\n\n\t\t\tconst condTokens = this.readTokensUntil( ')' );\n\n\t\t\treturn this.parseExpressionFromTokens( condTokens.slice( 1, condTokens.length - 1 ) );\n\n\t\t};\n\n\t\tconst parseIfBlock = ( cond ) => {\n\n\t\t\tif ( this.getToken().str === '{' ) {\n\n\t\t\t\tthis.parseBlock( cond );\n\n\t\t\t} else {\n\n\t\t\t\tcond.body.push( this.parseExpression() );\n\n\t\t\t}\n\n\t\t};\n\n\t\t//\n\n\t\tconst conditional = new Conditional( parseIfExpression() );\n\n\t\tparseIfBlock( conditional );\n\n\t\t//\n\n\t\tlet current = conditional;\n\n\t\twhile ( this.getToken() && this.getToken().str === 'else' ) {\n\n\t\t\tthis.readToken(); // skip 'else'\n\n\t\t\tconst previous = current;\n\n\t\t\tif ( this.getToken().str === 'if' ) {\n\n\t\t\t\tcurrent = new Conditional( parseIfExpression() );\n\n\t\t\t} else {\n\n\t\t\t\tcurrent = new Conditional();\n\n\t\t\t}\n\n\t\t\tprevious.elseConditional = current;\n\n\t\t\tparseIfBlock( current );\n\n\t\t}\n\n\t\treturn conditional;\n\n\t}\n\n\tparseBlock( scope ) {\n\n\t\tconst firstToken = this.getToken();\n\n\t\tif ( firstToken.str === '{' ) {\n\n\t\t\tthis.readToken(); // skip '{'\n\n\t\t}\n\n\t\tlet groupIndex = 0;\n\n\t\twhile ( this.index < this.tokens.length ) {\n\n\t\t\tconst token = this.getToken();\n\n\t\t\tlet statement = null;\n\n\t\t\tgroupIndex += getGroupDelta( token.str );\n\n\t\t\tif ( groupIndex < 0 ) {\n\n\t\t\t\tthis.readToken(); // skip '}'\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( token.isLiteral ) {\n\n\t\t\t\tif ( token.str === 'const' ) {\n\n\t\t\t\t\tstatement = this.parseVariables();\n\n\t\t\t\t} else if ( token.str === 'uniform' ) {\n\n\t\t\t\t\tstatement = this.parseUniform();\n\n\t\t\t\t} else if ( token.str === 'varying' ) {\n\n\t\t\t\t\tstatement = this.parseVarying();\n\n\t\t\t\t} else if ( isType( token.str ) ) {\n\n\t\t\t\t\tif ( this.getToken( 2 ).str === '(' ) {\n\n\t\t\t\t\t\tstatement = this.parseFunction();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstatement = this.parseVariables();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( token.str === 'return' ) {\n\n\t\t\t\t\tstatement = this.parseReturn();\n\n\t\t\t\t} else if ( token.str === 'if' ) {\n\n\t\t\t\t\tstatement = this.parseIf();\n\n\t\t\t\t} else if ( token.str === 'for' ) {\n\n\t\t\t\t\tstatement = this.parseFor();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstatement = this.parseExpression();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( statement ) {\n\n\t\t\t\tscope.body.push( statement );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_evalOperator( operator ) {\n\n\t\tif ( operator.type.includes( '=' ) ) {\n\n\t\t\tconst parameter = this._getFunctionParameter( operator.left.property );\n\n\t\t\tif ( parameter !== undefined ) {\n\n\t\t\t\t// Parameters are immutable in WGSL\n\n\t\t\t\tparameter.immutable = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn operator;\n\n\t}\n\n\t_getFunctionParameter( name ) {\n\n\t\tif ( this._currentFunction ) {\n\n\t\t\tfor ( const param of this._currentFunction.params ) {\n\n\t\t\t\tif ( param.name === name ) {\n\n\t\t\t\t\treturn param;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tparse( source ) {\n\n\t\tlet polyfill = '';\n\n\t\tfor ( const keyword of this.keywords ) {\n\n\t\t\tif ( new RegExp( `(^|\\\\b)${ keyword.name }($|\\\\b)`, 'gm' ).test( source ) ) {\n\n\t\t\t\tpolyfill += keyword.polyfill + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( polyfill ) {\n\n\t\t\tpolyfill = '// Polyfills\\n\\n' + polyfill + '\\n';\n\n\t\t}\n\n\t\tthis.index = 0;\n\t\tthis.tokenizer = new Tokenizer( polyfill + source ).tokenize();\n\n\t\tconst program = new Program();\n\n\t\tthis.parseBlock( program );\n\n\t\treturn program;\n\n\n\t}\n\n}\n\nexport default GLSLDecoder;\n", "import { Return, VariableDeclaration, Accessor } from './AST.js';\nimport GLSLDecoder from './GLSLDecoder.js';\n\nclass ShaderToyDecoder extends GLSLDecoder {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.addPolyfill( 'iTime', 'float iTime = time;' );\n\t\tthis.addPolyfill( 'iResolution', 'vec2 iResolution = screenSize;' );\n\t\tthis.addPolyfill( 'fragCoord', 'vec3 fragCoord = vec3( screenCoordinate.x, screenSize.y - screenCoordinate.y, screenCoordinate.z );' );\n\n\t}\n\n\tparseFunction() {\n\n\t\tconst node = super.parseFunction();\n\n\t\tif ( node.name === 'mainImage' ) {\n\n\t\t\tnode.params = []; // remove default parameters\n\t\t\tnode.type = 'vec4';\n\t\t\tnode.layout = false; // for now\n\n\t\t\tconst fragColor = new Accessor( 'fragColor' );\n\n\t\t\tfor ( const subNode of node.body ) {\n\n\t\t\t\tif ( subNode.isReturn ) {\n\n\t\t\t\t\tsubNode.value = fragColor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnode.body.unshift( new VariableDeclaration( 'vec4', 'fragColor' ) );\n\t\t\tnode.body.push( new Return( fragColor ) );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport default ShaderToyDecoder;\n"],
  "mappings": "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",
  "names": ["Program", "VariableDeclaration", "type", "name", "value", "next", "immutable", "Uniform", "Varying", "FunctionParameter", "qualifier", "FunctionDeclaration", "params", "Ternary", "cond", "left", "right", "Operator", "type", "Unary", "expression", "after", "Number", "value", "String", "Conditional", "FunctionCall", "name", "params", "Return", "Discard", "Accessor", "property", "StaticElement", "DynamicElement", "AccessorElements", "object", "elements", "For", "initialization", "condition", "afterthought", "unaryOperators", "precedenceOperators", "associativityRightToLeft", "glslToTSL", "samplers", "samplersCube", "samplers3D", "spaceRegExp", "lineRegExp", "commentRegExp", "inlineCommentRegExp", "numberRegExp", "stringDoubleRegExp", "stringSingleRegExp", "literalRegExp", "operatorsRegExp", "getFunctionName", "str", "getGroupDelta", "Token", "_Token", "tokenizer", "type", "pos", "TokenParserList", "Tokenizer", "source", "token", "params", "remainingCode", "i", "skip", "skipLength", "parser", "result", "nextToken", "isType", "GLSLDecoder", "name", "polyfill", "offset", "tokens", "output", "groupIndex", "firstToken", "lastToken", "operator", "parseToken", "inverse", "conditionTokens", "leftTokens", "rightTokens", "condition", "left", "right", "Ternary", "Operator", "Unary", "isHex", "Number", "String", "Return", "Discard", "secondToken", "internalTokens", "paramsTokens", "functionCall", "FunctionCall", "accessTokens", "elements", "AccessorElements", "Accessor", "currentTokens", "accessorTokens", "element", "DynamicElement", "StaticElement", "expression", "current", "immutable", "qualifier", "FunctionParameter", "func", "FunctionDeclaration", "index", "init", "next", "initTokens", "expressionTokens", "nextTokens", "VariableDeclaration", "Uniform", "Varying", "forTokens", "initializationTokens", "afterthoughtTokens", "initialization", "afterthought", "statement", "For", "parseIfExpression", "condTokens", "parseIfBlock", "cond", "conditional", "Conditional", "previous", "scope", "parameter", "param", "keyword", "program", "Program", "GLSLDecoder_default", "ShaderToyDecoder", "GLSLDecoder_default", "node", "fragColor", "Accessor", "subNode", "VariableDeclaration", "Return", "ShaderToyDecoder_default"]
}
